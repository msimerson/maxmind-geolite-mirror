#!/usr/bin/env node
'use strict';

const fs    = require('fs');
const http  = require('http');
const zlib  = require('zlib');

const config = require('../lib/config');

function httpReqOpts () {
    return {
        method: 'HEAD',
        hostname: config.hostName,
        port: config.hostPort,
        headers: {
            'User-Agent': config.userAgent,
        },
        agent: false,
    };
}

function isRemoteNewer (dest, httpOpts, done) {

    if (!fs.existsSync(dest)) {
        // console.log(dest + ' does not exist');
        return done(true);
    }

    const stats = fs.statSync(dest);
    if (!stats.isFile()) {
        console.error(dest + ' is not a file');
        fs.unlink(dest, () => {
            console.log(dest + ' deleted');
            return done(true);
        })
    }

    httpOpts.headers['If-Modified-Since'] = stats.mtime.toUTCString();

    const request = http.request(httpOpts, (res) => {
        if (res.statusCode === 304) {
            console.log(dest + ' is up-to-date');
            return done(false);
        }

        if (res.statusCode === 200) return done(true);

        console.log(res.statusCode);
        console.log('HEADERS: ' + JSON.stringify(res.headers));
        done(true);
    })
        .on('error', (e) => {
            console.error(e);
            done(false);
        });
    request.end();
}

function handleTarball (dest, res, callback) {
    let untar = null;
    try {
        untar = require('tar-stream').extract();
    }
    catch (err) {
        return callback(`cannot open ${res.path}, tar-stream package is not available.`);
    }

    let foundFile = false;
    untar.on('entry', (header, stream, cb) => {
        if (!/\.mmdb$/.test(header.name))
            return cb();
        // use dest for first matching filename; warn & drop files for subsequent matches
        if (foundFile) {
            console.error(`WARNING: encountered more than one mmdb file in .tar.gz. Saving first match (${foundFile}) as ${dest}.`);
            return cb();
        }
        else {
            const outstream = fs.createWriteStream(`${dest}.tmp`);
            outstream.on('finish', () => {
                fs.rename(`${dest}.tmp`, dest, cb);
            });
            stream.pipe(outstream);
            foundFile = header.name;
        }
    });

    untar.on('finish', callback);

    res.pipe(zlib.createGunzip()).pipe(untar);
}

function download (dest, opts, done) {

    const request = http.request(opts, (res) => {
        if (res.statusCode !== 200) {
            console.error('response code ' + res.statusCode + ' not handled!');
            console.error('HEADERS: ' + JSON.stringify(res.headers));
            return;
        }

        // handle tarballs as necessary
        if (/\.tar\.gz$/.test(opts.path))
            return handleTarball(dest, res, done);

        const file = fs.createWriteStream(dest + '.tmp');
        res.pipe(zlib.createGunzip()).pipe(file);
        file.on('finish', () => {
            // console.log("wrote to file " + dest + '.tmp');
            file.close((err) => {
                if (err) throw err;
                // console.log("moved " + dest + '.tmp to ' + dest);
                fs.rename(dest + '.tmp', dest, (err2) => {
                    if (err2) throw err2;
                    console.log('saved ' + dest);
                    done();
                });
            });
        });
    })
        .on('error', (e) => {
            console.error(e);
            fs.unlink(dest, () => {
            // It's unlikely the file exists. In the general case, this
            // callback catches the error and...ignores it.
            })
            if (done) done('err: ' + e.message);
        });

    request.end();
}

function doOne (item, done) {

    const opts = new httpReqOpts();
    opts.path = config.urlPath + item.remote;

    const dest = config.dbDir  + item.local;

    isRemoteNewer(dest, opts, (shouldGet) => {
        if (!shouldGet) return done();

        console.log('downloading ' + dest);
        opts.method = 'GET';
        download(dest, opts, done);
    })
}

function main(callback) {
    try {
        // check each file, in series (poor mans async.eachSeries)
        doOne(config.geoIpDbs.shift(), function iterator () {
            if (!config.geoIpDbs.length) return callback();
            doOne(config.geoIpDbs.shift(), iterator);
        });
    }
    catch (err) {
        return callback(err);
    }
}

if (require.main === module)
    main();

module.exports = { download: download, main: main };
